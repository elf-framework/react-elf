import { Controls, Canvas, Meta, Unstyled } from "@storybook/blocks";
import { Button } from "@react-elf/ui";
import * as ButtonStories from "./Button.stories";
import { ButtonVariantItem } from "./ButtonVariantItem";

import { ContainerView } from "../../ui/ContainerView";

<Meta title="Components/Actions/Button" of={ButtonStories} />

# Button

Buttons allow users to perform an action or to navigate to another page. They have multiple styles for various needs, and are ideal for calling attention to where a user needs to do something in order to move forward in a flow.

## Usage

<Canvas of={ButtonStories.ExtraLargePrimary} sourceState="shown" />

{/* <Controls exclude={["onClick"]} /> */}

## Options

### Label and icon

Buttons should always have a label, unless they are only using an icon that is universally understood and accessible. They can have an optional icon, but it should not be used for decoration. Use an icon only when necessary and when it has a strong association with the label text.

The label can be hidden to create an icon-only button. If the label is hidden, an icon is required, and the label will appear in a tooltip.

<Unstyled>
<ContainerView>
    <ButtonVariantItem 
        width={200}
        name="With label and icon"
        button1={ButtonStories.WithLabelAndIcon}
    />

    <ButtonVariantItem
        width={200}
        name="Without icon"
        button1={ButtonStories.WithoutIcon}
    />

    <ButtonVariantItem
        width={200}
        name="With label and icon hidden"
        button1={ButtonStories.WithIconAndLabelHidden}
    />

</ContainerView>
</Unstyled>

<Canvas of={ButtonStories.WithLabelAndIcon} sourceState="shown" />

### Variant

The accent button communicates strong emphasis and is reserved for actions that are essential to an experience. Don’t use more than 3 accent buttons in the same view. These give extra prominence to important actions and are meant to establish a clear hierarchy.

<Unstyled>
<ContainerView>
  <ButtonVariantItem
    name="default"
    button1={ButtonStories.Default}
    button2={ButtonStories.DefaultOutline}
  />
  <ButtonVariantItem
    name="primary"
    button1={ButtonStories.Primary}
    button2={ButtonStories.PrimaryOutline}
  />
  <ButtonVariantItem
    name="secondary"
    button1={ButtonStories.Secondary}
    button2={ButtonStories.SecondaryOutline}
  />

    <ButtonVariantItem
        name="danger"
        button1={ButtonStories.Danger}
        button2={ButtonStories.DangerOutline}
    />

    <ButtonVariantItem
        name="warning"
        button1={ButtonStories.Warning}
        button2={ButtonStories.WarningOutline}
    />

    <ButtonVariantItem
        name="success"
        button1={ButtonStories.Success}
        button2={ButtonStories.SuccessOutline}
    />

    <ButtonVariantItem
        name="info"
        button1={ButtonStories.Info}
        button2={ButtonStories.InfoOutline}

    />

    <ButtonVariantItem
        name="dark"
        button1={ButtonStories.Dark}
        button2={ButtonStories.DarkOutline}
    />

</ContainerView>
</Unstyled>

<Canvas of={ButtonStories.Primary} sourceState="shown" />
<Canvas of={ButtonStories.PrimaryOutline} sourceState="shown" />

### Size

<Unstyled>
<ContainerView>
  <ButtonVariantItem
    name="extra-small"
    button1={ButtonStories.ExtraSmall}
  />
    <ButtonVariantItem
        name="small"
        button1={ButtonStories.Small}
    />
    <ButtonVariantItem
        name="default"
        button1={ButtonStories.Default}
    />
    <ButtonVariantItem
        name="large"
        button1={ButtonStories.Large}
    />
    <ButtonVariantItem
        name="extra-large"
        button1={ButtonStories.ExtraLarge}
    />

</ContainerView>
</Unstyled>

Buttons come in four different sizes: small, medium, large, and extra-large. The medium size is the default and most frequently used option. Use the other sizes sparingly; they should be used to create a hierarchy of importance within the page.

<Canvas of={ButtonStories.Small} sourceState="shown" />

## Justified

<Unstyled>
<ContainerView>
  <ButtonVariantItem
    layout="vertical"
    name="justified"
    button1={ButtonStories.Justified}
    button2={ButtonStories.JustifiedWithIcon}
  />

</ContainerView>
</Unstyled>

A button can become justified. By default, it is not justified since the button size depends on the label and/or icon inside of each button. When a button is justified, it takes up the entire available container width.

<Canvas of={ButtonStories.Justified} sourceState="shown" />

## Pending

<Unstyled>
<ContainerView>
  <ButtonVariantItem
    name="small"
    button1={ButtonStories.PendingSmall}
  />
    <ButtonVariantItem
        name="default"
        button1={ButtonStories.PendingDefault}
    />
    <ButtonVariantItem
        name="large"
        button1={ButtonStories.PendingLarge}
    />
    <ButtonVariantItem
        name="extra-large"
        button1={ButtonStories.PendingExtraLarge}
    />

</ContainerView>
</Unstyled>

Buttons can indicate that a quick progress taking place (e.g., saving settings on a server). In this case, the label and optional icon disappear and a progress circle appears. The progress circle always shows an indeterminate progress.

Use the pending state for a button sparingly. It should be reserved only for when the progress is supposed to be quick (taking 5 seconds or less), and when there is no better way to communicate as such.

<Canvas of={ButtonStories.PendingExtraLarge} sourceState="shown" />

## Disabled

<Unstyled>
<ContainerView>

    {ButtonStories.DisabledPreview.render()}

</ContainerView>
</Unstyled>

A button in a `disabled` state shows that an action exists, but is not available in that circumstance. This state can be used to maintain layout continuity and to communicate that an action may become available later.

<Canvas of={ButtonStories.DisabledFill} sourceState="shown" />

## Focus

<Unstyled>
<ContainerView>

    {ButtonStories.FocusPreview.render()}

</ContainerView>
</Unstyled>

A button can be navigated using a keyboard. The keyboard focus state takes the button’s visual hover state and adds a blue ring to the button in focus.

<Canvas of={ButtonStories.Focus} sourceState="shown" />

## Tooltip

<Unstyled>
<ContainerView>

    {ButtonStories.TooltipPreview.render()}

</ContainerView>
</Unstyled>

When the button label is hidden, a tooltip is shown on hover that displays the label text and, if appropriate, a keyboard shortcut.

```jsx dark
import { Button, Tooltip } from "@react-elf/ui";

function App() {
  return (
    <Tooltip message={"Share"} show placement="top" variant="dark">
      <Button shape="round" variant="primary" iconOnly>
        <FaBeer />
      </Button>
    </Tooltip>
  );
}
```
